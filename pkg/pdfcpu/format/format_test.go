/*
Copyright 2023 The pdfcpu Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package format

import (
	"strings"
	"testing"

	"github.com/pdfcpu/pdfcpu/pkg/pdfcpu/model"
)

func TestTextNoPlaceholders(t *testing.T) {
	tests := []struct {
		name   string
		text   string
		want   string
		unique bool
	}{
		{"empty string", "", "", false},
		{"plain text", "Hello World", "Hello World", false},
		{"no placeholders", "Page 1 of 10", "Page 1 of 10", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, unique := Text(tt.text, "", 1, 10)
			if got != tt.want {
				t.Errorf("Text() = %q, want %q", got, tt.want)
			}
			if unique != tt.unique {
				t.Errorf("Text() unique = %v, want %v", unique, tt.unique)
			}
		})
	}
}

func TestTextPageNumber(t *testing.T) {
	tests := []struct {
		name      string
		text      string
		pageNr    int
		pageCount int
		want      string
	}{
		{"page number zero offset", "%p0", 5, 10, "5"},
		{"page number with offset", "%p10", 5, 10, "15"},
		{"page number in text", "Page %p0", 3, 10, "Page 3"},
		{"page number at end", "Page %p0", 7, 10, "Page 7"},
		{"page number with large offset", "%p100", 1, 10, "101"},
		{"multiple page numbers", "%p0 of %p0", 5, 10, "5 of 5"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, unique := Text(tt.text, "", tt.pageNr, tt.pageCount)
			if got != tt.want {
				t.Errorf("Text() = %q, want %q", got, tt.want)
			}
			if !unique {
				t.Error("Text() should return unique=true for page number placeholder")
			}
		})
	}
}

func TestTextPageCount(t *testing.T) {
	tests := []struct {
		name      string
		text      string
		pageNr    int
		pageCount int
		want      string
	}{
		{"page count only", "%P", 1, 100, "100"},
		{"page count in text", "Total: %P pages", 1, 50, "Total: 50 pages"},
		{"page and count", "Page %p0 of %P", 5, 20, "Page 5 of 20"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, unique := Text(tt.text, "", tt.pageNr, tt.pageCount)
			if got != tt.want {
				t.Errorf("Text() = %q, want %q", got, tt.want)
			}
			if !unique {
				t.Error("Text() should return unique=true for page count placeholder")
			}
		})
	}
}

func TestTextVersion(t *testing.T) {
	text := "Generated by pdfcpu %v"
	got, unique := Text(text, "", 1, 1)

	if !strings.Contains(got, model.VersionStr) {
		t.Errorf("Text() = %q, should contain version %q", got, model.VersionStr)
	}
	if !unique {
		t.Error("Text() should return unique=true for version placeholder")
	}
}

func TestTextTimestamp(t *testing.T) {
	text := "Created: %t"
	format := "2006-01-02"
	got, unique := Text(text, format, 1, 1)

	// Just verify it starts with "Created: " and has a date-like format
	if !strings.HasPrefix(got, "Created: ") {
		t.Errorf("Text() = %q, should start with 'Created: '", got)
	}
	// The timestamp part should be 10 chars (YYYY-MM-DD)
	timestamp := strings.TrimPrefix(got, "Created: ")
	if len(timestamp) != 10 {
		t.Errorf("Timestamp = %q, expected length 10", timestamp)
	}
	if !unique {
		t.Error("Text() should return unique=true for timestamp placeholder")
	}
}

func TestTextEscapedPercent(t *testing.T) {
	tests := []struct {
		name   string
		text   string
		want   string
		unique bool
	}{
		{"double percent", "100%%", "100%", false},
		{"double percent in text", "Discount: 50%% off", "Discount: 50% off", false},
		// Note: %%t is treated as escaped % followed by %t (timestamp), so unique becomes true
		{"escaped before plain", "%%x", "%x", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, unique := Text(tt.text, "", 1, 10)
			if got != tt.want {
				t.Errorf("Text() = %q, want %q", got, tt.want)
			}
			if unique != tt.unique {
				t.Errorf("Text() unique = %v, want %v", unique, tt.unique)
			}
		})
	}
}

func TestTextCombined(t *testing.T) {
	tests := []struct {
		name      string
		text      string
		pageNr    int
		pageCount int
		wantPart  string
	}{
		{
			name:      "page and count with text",
			text:      "Page %p0 of %P",
			pageNr:    3,
			pageCount: 10,
			wantPart:  "Page 3 of 10",
		},
		{
			name:      "page with offset and count",
			text:      "Page %p1 of %P",
			pageNr:    0,
			pageCount: 5,
			wantPart:  "Page 1 of 5",
		},
		{
			name:      "escaped and page",
			text:      "100%% - Page %p0",
			pageNr:    7,
			pageCount: 10,
			wantPart:  "100% - Page 7",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, unique := Text(tt.text, "", tt.pageNr, tt.pageCount)
			if got != tt.wantPart {
				t.Errorf("Text() = %q, want %q", got, tt.wantPart)
			}
			if !unique {
				t.Error("Text() should return unique=true for dynamic placeholders")
			}
		})
	}
}

func TestTextUnknownPlaceholder(t *testing.T) {
	// Unknown placeholder like %x should just output the character after %
	text := "Test %x value"
	got, unique := Text(text, "", 1, 10)

	// The %x is not a known placeholder, so x should appear
	if got != "Test x value" {
		t.Errorf("Text() = %q, want %q", got, "Test x value")
	}
	if unique {
		t.Error("Text() should return unique=false for unknown placeholder")
	}
}

func TestTextPageNumberAtEnd(t *testing.T) {
	// Test the case where page number placeholder is at the very end
	text := "Page %p5"
	got, _ := Text(text, "", 10, 20)
	if got != "Page 15" {
		t.Errorf("Text() = %q, want %q", got, "Page 15")
	}
}

func TestTextTrailingPercent(t *testing.T) {
	// Test trailing percent sign
	text := "100%"
	got, unique := Text(text, "", 1, 10)
	// A trailing % with nothing after should just be ignored (not output)
	if got != "100" {
		t.Errorf("Text() = %q, want %q", got, "100")
	}
	if unique {
		t.Error("Text() should return unique=false for trailing percent")
	}
}
